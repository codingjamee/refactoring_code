### 리팩터링 원칙

#### 2.1 리팩터링 정의

##### 리팩터링 : 겉보기 동작 유지, 코드를 이해하기 쉽고 수정하기 쉽도록 내부 구조를 변경하는 기법

##### 리팩터링하다 : 소트웨어 겉보기 동작은 유지한 채 리팩터링 기법을 적용해서 소프트웨어 재구성

- 리팩터링 전과 후의 동작은 똑같아야 한다.
- 사용자 관점에서 달라지면 안된다.
- 버그가 이전과 동일해야 한다 (아무도 발견 못한 버그는 수정 가능)
- 목적은 코드를 이해하고 수정하기 쉽게

#### 2.2 두 개의 모자

- 개발의 목적에 따라 기능추가의 모자, 리팩터링의 모자 두개로 나뉨
- 기능 추가 모자일 때는 기존 코드를 건드리지 않음
- 리팩터링 모자일 때는 기능추가 하지 않음 (테스트도 새로 추가하지 않음)

#### 2.3 리팩터링 하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다.
  - 코드의 구조를 무너뜨리지 않게 됨
  - 중복 코드를 줄이면 설계개선에 도움이 된다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
  - 프로그래밍은 내가 원하는 바를 표현하는 일
  - 코드의 목적이 더 잘 드러나게 개선(나 자신을 위해)
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
  - 리팩터링 하면 코드가 하는 일을 깊게 파악하기 떄문
  - 견고한 코드 작성에 효과적
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.
  - 기존에 코드 활용 가능, 새기능 빨리 추가
  - 어디에 추가할지, 어디를 고칠지 쉽게 파악가능
  - 버그 가능성 낮음
  - 디버깅 쉬움
- 지구력 가설
  - 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아짐

#### 2.4 언제 리팩터링 해야할까?

- 3의 법칙

1. 처음엔 그냥
2. 두번째는 계속 진행
3. 비슷한 일 세번째 했을 때 리팩터링

- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
  - 새로운 기능 추가 직전이 가장 좋은 시점
  - 리터럴 값 몇 개가 방해되는 함수일 경우 함수 매개변수화 하기
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 코드를 수정하기 위해 이해할 때 더 의도가 명확해지도록
  - 이해된 부분을 코드로 옮겨 담기
- 쓰레기 줍기 리팩터링
  - 로직을 쓸데없이 나눌 경우를 예방하여 간단한 수정은 고치고 시간걸리는 일은 메모를 남긴다
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 보기싫은 코드를 발견하면 리팩터링 잘 된 코드도 여러번 리팩터링
  - 수정하려 할 떄 수정하기 쉽게 정돈한 다음 쉽게 수정
  - 리팩터링은 드러나지 않게 기회가 될 때마다
  - 커밋을 나누든 함께하든 팀에 적합한 방식을 실험을 통해 찾아낼 것
- 오래 걸리는 리팩터링
  - 오래 걸리는 것은 몇주에 걸쳐 조금씩 해결하는 것이 효과적
- 코드 리뷰에 리팩터링 활용하기
  - 코드리뷰는 경험이 많은 개발자의 노하우를 전수하는 데 효율적
  - 풀 요청 모델보다 짝 프로그래밍이 더 효과적
- 관리자에게는 뭐라고 말해야 할까?
  - 누적된 오류나 가치있는 기능을 만들어 내지 못하는 작업으로 오해
  - 어설픈 재구성으로 코드 베이스를 망가뜨리기도
  - 부정적이라면 말하지 않는것도 방법
  - 리팩터링은 소프트웨어를 빠르게 만드는데 효과적이기 때문
- 리팩터링 하지 말아야 할 때
  - 굳이 수정할 필요가 없을 때
  - 새로 작성하는 게 쉬울 떄

#### 2.5 리팩터링 시 고려할 문제

- 새 기능 개발 속도 저하
  - 건드릴 일이 없거나 불편하지 않을 떄 리팩터링 하지 않음
  - 어떠헥 해야할 지 확실히 떠오르지 않을 때
  - 리팩터링은 개발기간을 단축하고자 하는 것
- 코드 소유권
  - 쓰기권한이 없는 경우는 공개된 인터페이스일 경우
    - 기존 함수 유지 및 새 함수 호출하도록 바꾸기
  - 코드의 소유권은 팀에 두는 것이 좋다
  - 다른 팀이 브랜치를 따서 수정하고 커밋 요청할 수도 있다.
- 브랜치
  - 각 브랜치별로 만들고 릴리즈 할 때 통합하는 경우
    - 장점
      - 기능 추가시 버전을 나눌 수 있음
      - 문제가 생기면 쉽게 되돌릴 수 있음
    - 단점
      - 작업기간이 길어지면 마스터 통합이 어려워짐
  - 기능별 브랜치 통합 2~3일 단위 (지속적 통합 CI)
    - 마스터 건강히 유지
    - 기능 잘게 쪼개기
    - 기능 플래그 적용 (완료되지 않은 기능 시스템 망치지 않도록)
    - 켄트 백의 익스트림 프로그래밍 (CI + 리팩터링)
  - 트렁크 기반 개발 (TBD)
- 테스팅
  - 오류를 빨리 잡는 것이 핵심
  - 리팩터링을 위해서는 자가 테스트 코드가 있어야 함
  - 버그를 빨리 찾을 수 있음
  - CI와도 밀접한 연관 XP의 권장사항 CD의 핵심
- 레거시 코드
  - 파악시 리팩터링이 도움됨
  - 테스트 보강 필요
  - 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야
  - 처음부터 자가 테스트 코드 작성 필요
  - 자주보는 부분을 더 많이 리팩터링
- 데이터베이스
  - 커다란 변경들을 쉽게 조합하구 다룰수 있는 마이그레이션 스크립트 작성
  - 구조적 변경을 스크립트로 처리 통합
  - 전체 변경과정을 작고 독립된 단계로 쪼갬
  - 병렬-수정 (챙창-수축)

#### 2.6 리팩터링, 아키텍처, 애그니

- 소프트웨어 아키텍처 관점의 전환

  - 이전에는 코딩 시작 전 설계와 아키텍처는 코딩전 완료하고 바꿀 수 없어야 한다고 생각
  - 수년 운영되는 소프트웨어도 아키텍처 대폭 변경 가능

    - 탄탄한 테스트 중요
    - 요구사항 변화에 자연스럽게 대응할 코드베이스 설계 가능

    - 유연성 메커니즘으로 다양한 시나리오에 대응 매개변수 추가
    - 리팩터링 활용시
      - 현재까지 파악 요구사항을 해결
      - 진행이후 그에 맞게 리팩터링
      - 간결한 설계, 점진적 설계, YAGNI애그니

#### 2.7 리팩터링과 소프트웨어 개발 프로세스

- XP도입으로 리팩터링이 퍼지기시작 (특징 : 지속적 통합, 자가테스트 코드, 리팩터링)
- 테스트 주도 개발 (TDD): 자가테스트 코드, 리팩터링
- 리팩터링의 토대
  - 1. 자가테스트
    - 리팩터링 중 오류를 자동으로 걸러냄
  - 2. 지속적 통합
    - 팀원각자 수행한 결과를 빠르게 공유 가능
  - 3. 리팩터링
- 이것을 잘 살린다면 YAGNI설계방식으로 개발 진행 가능
- 요구사항 변화에 빠르고 안정적인 선순환 구조를 코드베이스에 이식 가능
- 지속적 배포 여러차례 릴리스 가능

#### 2.8 리팩터링과 성능

- 직관적인 설계 vs 성능
  - 튜닝하기 쉽게 만들고 원하는 속도가 나게끔 튜닝
- 빠른 소프트웨어 작성하는 방법
  - 1. 시간 예산 분배 방식
    - 설계를 여러 컴포넌트로 나눠 컴포넌트마다 자원, 예산 할당
    - 할당된 시간 초과불가
  - 2. 끊임없이 관심을 기울이는 것
    - 높은 성능을 위해 관심
    - 효과는 변변치 않음
    - 다루기 어려운 프로그램이 될 확률
    - 성능을 높이는건 90% 효과가 없음
  - 3. 의도적 성능 최적화 전에는 코드를 다루기 쉽게 만드는데 집중
    - 그다음 순서
      - 1. 시간, 공간 많이 잡아먹는 지점 알아내기
      - 2. 개선
      - 3. 작은단계로 나눠서 진행
      - 4. 컴파일 테스트 프로파일러 실행
      - 5. 개선되지 않았따면 되돌림
      - 6. 반복

#### 2.9 리팩터링의 유래

- 워드 커닝햄, 켄트백의 스몰토크에서 빠른 수정작업 진행, XP탄생
- 존 브랜트, 돈 로버츠 리팩터링 도구인 리팩터링 브라우저 개발

#### 2.10 리팩터링 자동화

- 자동 리팩터링 지원 도구
  - 인텔리제이, 이클립스
  - 리팩터링 브라우저
  - 변수 추출하기 등 텍스트 조작 (찾아 바꾸기)
  - 구문트리로 해석하는 자동 리팩터링
  - 정적 타입 언어는 안전한 리팩터링 수가 늘어남

#### 2.11 더 알고 싶다면

- 윌리엄 에이크 저 리팩터링 워크북 (인사이트, 2006)
- 조슈아 케리에프스키 저 패턴을 활용한 리팩터링 (인사이트, 2011)
- 스캇 엠블러 저 리팩토링 데이터베이스 (위키북스, 2006)
- 엘리엇 러스티 해롤드 저 리팩토링 HTML (에이콘, 2009)
- 마이클 페더스 레거시 코드 활용 전략 (에이콘, 2018) 
- 제이필즈 셰인하비 저 Refactoring (웰슬리, 2009)