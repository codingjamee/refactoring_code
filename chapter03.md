## 03 코드에서 나는 악취

- 리팩터링을 언제 시작하고 그만할지 판단하는 일은 중요
- 각자 경험을 통해 감을 키워야

### 3.1 기이한 이름

- 코드는 단순하고 명료하게
- 이름이 중요
- 무슨일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록
- 혼란스러운 이름을 정리하면 코드가 간결해질 때가 많다

### 3.2 중복 코드

- 중복되면 차이점을 깊게 봐야함
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 함수 추출하기로 추출된 메서드를 호출하게 바꾸라

### 3.3 긴 함수

- 오랜시간 잘 활용되는 프로그램은 짧은 함수로 구성
- 간접 호출의 효과
- 좋은 이름은 본문을 볼 이유가 사라짐
- 함수 이름은 의도가 드러나도록
- 의도와 코드의 괴리가 큰지 확인 설명하지 못한다면 함수로
- 함수 짧게 만드려면 함수 추출
- 추출할 코드덩어리는 주석으로

### 3.4 긴 매개변수 목록

- 매개변수는 질의함수로 변경
- 데이터에서 값을 빱아 매개변수로 전달한다면 객체 통째로 넘기기
- 함께 전달되는 매개변수는 매개변수 객체 만들기
- 함수 동작방식 플래그 매개변수는 플래그 인수 제거하기
- 여러 함수가 특정 매개변수값을 공통으로 사용할때 여러 함수를 클래스로 묶기

### 3.5 전역 데이터

- 가장 문제
- 코드 베이스 어디서건 건드릴 수 있고 누가 바꿨는지 찾아낼 수 없음
- 변수 캡슐화 하기
- 접근자 함수는 클래스나 모듈에 넣어 접근범위 출이기
- 전역 데이터가 조금만 있더라도 캡슐화

### 3.6 가변 데이터

- 함수형 프로그래밍 데이터 불변성 유지 변경하려면 복사본을 만들어 반환
- 변수 캡슐화 하기
- 값을 갱신하려면 변수 쪼개기
- 갱신로직은 문장 슬라이스와 함수 추출하기
- 질의함수와 변경함수 분리하기
- 세터 제거하기
- 가변데이터는 파생변수를 질의함수로 바꾸기

### 3.7 뒤엉킨 변경

- 소프트웨어 구조를 변경하기 쉬운 형태로 조직할 것
- 소프트웨어는 소프트 해야
- 단일 책임 원칙을 지켜야 
- 순서대로 실행되는게 자연스럽다면 단계 쪼개기 
- 다른 맥락 함수 호출 빈도 높다면 함수 옮기기
- 여러 맥락에 관여하는 함수가 있다면 함수 추출하기 
- 모듈이 클래스라면 클래스 추출하기

### 3.8 산탄총 수술

- 코드를 변경할때마다 자잘하게 수정해야 하는 클래스가 많을 때 
- 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 묶기
- 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기
- 데이터 구조 변환 보강 함수에는 여러 함수를 변환 함수로 묶기 
- 다음단계의 로직으로 전달 단계 쪼개기
- 어설프게 분리된 로직을 함수 인라인하기 / 클래스 인라인하기

### 3.9 기능 편애

- 모듈화시 영역으로 나눈 뒤 영역 안에서 상호작용 늘리고 영역 사이에 이뤄지는 상호작용 최소로 줄이기
- 외부 객체의 게터 메서드 여러개 호출하는 함수는 데이터 근처로 옮겨주기 (함수 옮기기)
- 함수 일부분에서라면 그부분만 함수 추출하기, 원하는 모듈로 함수 옮기기
- 명확하지 않은 경우 데이터를 많이 포함한 모듈로 옮김

### 3.10 데이터 뭉치 

- 필드형태의 데이터 뭉치를 찾아 클래스 추출하기 
- 메서드 시그니처에 있는 데이터 뭉치 매개변수 객체 만들기, 객체 통째로 넘기기
- 데이터 뭉치인지 판별하려면 값을 삭제해 나머지 데이터만으로 의미가 없다면 객체로 환생

### 3.11 기본형 집착 

- 대부분의 프로그래밍언어는 기본형을 제공 
- 기본형을 객체로 바꾸기
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드일 경우 타입코드를 서브클래스로 바꾸기와 조건부 로직을 다형성으로 바꾸기를 차례로 적용
- 함께 몰려다니는 기본형 그룹 클래스 추출하기와 매개변수 객체 만들기

### 3.12 반복되는 switch문

- 중복된 switch문이면 조건절 추가할 때마다 다른 switch문을 수정해야 했기 때문

### 3.13 반복문

- 반복문을 파이프라인으로 바꾸기
- filter나 map 파이프라인 연산을 사용하면 원소 처리 파악이 쉬움 

### 3.14 성의 없는 요소

- 코드 구조잡을 때 프로그램 요소 사용 
- 구조가 필요없을 경우 함수 인라인하기 클래스 인라인하기 계층 합치기

### 3.15 추측성 일반화

- 나중에 필요할거란 생각으로 당장 필요없는 후킹포인트 케이스처리 로직 
- 하는일이 거의없는 추상클래스는 계층합치기
- 쓸데없이 위임하는 코드는 함수/클래스 인라인하기
- 본문에서 사용되지 않는 매개변수 함수 선언바꾸기
- 추측성 일반화 테스트 말고 사용하는 곳이 없는 함수나 클래스인 경우 테스트 삭제 후 죽은 코드 제거하기

### 3.16 임시 필드

- 특정 상황에서만 값이 설정되는 필드는 클래스 추출하기
- 그다음 함수 옮기기 
- 특이 케이스 추가하기 

### 3.17 메시지 체인

- 다른 객체를 요청하는 작업이 연쇄적으로 이루어 지는 경우
- 위임 숨기기 
- 함수 추출하기 함수옮기기로 숨길 수 있는지 확인

### 3.18 중개자

- 외부로부터 세부사항을 숨겨주는 캡슐화
- 중개자 제거하기로 직접 소통

### 3.19 내부자 거래 

- 모듈사이의 데이터 거래가 많을시 함수 옮기기와 필드 옮기기
- 상속 구조에서 자식이 부모에대해 너무 많이 알려고 할 때 서브클래스를 위임으로 바꾸거나 슈퍼 클래스를 위임으로 바꾸기

### 3.20 거대한 클래스

- 클래스가 너무 많은 일을 하면 필드수가 늘어남 
- 클래스 추출하기로 필드들 일부를 따로 묶기
- 분리할 컴포넌트가 원래 클래스와 상속관계가 좋다면  슈퍼클래스 추출하기 나 타입 코드를 서브 클래스로 바꾸기
- 코드량이 너무 많은 클래스 중복 제거 

### 3.21  서로 다른 인터페이스의 대안 클래스들 

- 클래스 장점 다른 클래스로 교체 가능 
- 함수 선언 바꾸기 메서드 시그니처 일치 
- 부족한 경우 함수 옮기기를 이용하여 인터페이스 같아질 때까지 필요한 동작을 클래스 안으로 밀어 넣기 

### 3.22 데이터 클래스 

- pulic필드가 있다면 레코드 캡슐화 하기로 숨기기 
- 변경하면 안되는 경우 세터 제거하기
- 함수 옮기기로 데이터 클래스로 옮길 수 있는지 
- 통째옮길 수 없는 경우 함수 추출하기 

### 3.23 상속 포기

- 서브 클래스를 만들어 메서드 내리기 필드 내리기를 활용하여 부모 클래스 코드를 옮김
- 부모의 동작은 필요하지만 인터페이스는 따르고 싶지 않을 떄 
- 서브 클래스를 위임으로 바꾸거나 슈퍼클래스를 위임으로 바꾸기 

### 3.24 주석 

- 주석이 탈취제로 쓰이는 경우 
- 주석을 남기고 싶다면 함수 추출하기
- 여전히 설명이 필요하다면 함수 선언 바꾸기
- 선행 조건 명시하고 싶다면 어서션 추가하기 
- 확실하지 않은 부분에 주석 남김

